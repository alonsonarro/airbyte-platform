import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.github.spotbugs.snom.SpotBugsTask

buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }
    dependencies {
        classpath 'com.bmuschko:gradle-docker-plugin:7.2.0'
    }
}

plugins {
    id 'base'
    id 'com.diffplug.spotless' version '6.12.0'
    id 'com.github.hierynomus.license' version '0.16.1'
    id 'com.github.spotbugs' version '5.0.13'
    id 'version-catalog'
}

repositories {
    mavenCentral()
    maven {
        url 'https://airbyte.mycloudrepo.io/public/repositories/airbyte-public-jars/'
    }
}

Properties env = new Properties()
rootProject.file('.env.dev').withInputStream { env.load(it) }


/*
oss_version: used to reference OSS images/jars that are dependencies of wrapped Cloud apps/images.
  - example: cloud-bootloader has a dependency on `io.airbyte:airbyte-server:$rootProject.ext.oss_version`

cloud_version: used to tag and reference Cloud-specific build artifacts independently of the oss_version

image_tag: used to tag and reference Cloud-specific docker images independently of OSS images
 */
def getVersion = System.getenv("VERSION") ?: env.VERSION
println "Version: ${getVersion}"
def getImageTag = System.getenv("VERSION") ?: 'dev'

ext {
    oss_version = getVersion
    protocol_version = "1.0.0"
    cloud_version = getVersion
    image_tag = getImageTag
}

def createLicenseWith = { File license, String startComment, String endComment, String lineComment, boolean isPython ->
    /*
    In java, we don't have a second linter/styling tool other than spotless so it doesn't really
    matter if we write a newline or not for startComment/endComment.

    However, in python, we are using black that double-checks and reformats the code.
    Thus, writing an extra empty newline (not removed by trimTrailingWhitespace() is actually a
    big deal and would be reformatted (removed) because of black's specs.
    */
    def tmp = File.createTempFile('tmp', '.tmp')
    tmp.withWriter {
        def w = it
        if (startComment.length() > 0 || !isPython) {
            w.writeLine(startComment)
        }
        license.eachLine {
            w << lineComment
            w.writeLine(it)
        }
        if (endComment.length() > 0 || !isPython) {
            w.writeLine(endComment)
        }
        w.writeLine("")
        if (isPython) {
            w.writeLine("")
        }
    }
    return tmp
}

def createPythonLicenseWith = { license ->
    return createLicenseWith(license, '', '', '', true)
}

def createJavaLicenseWith = { license ->
    return createLicenseWith(license, '/*', ' */', ' * ', false)
}

// We are the spotless exclusions rules using file tree. It seems the excludeTarget option is super finicky in a
// monorepo setup and it doesn't actually exclude directories reliably. This code makes the behavior predictable.
def createSpotlessTarget = { pattern ->
    def excludes = [
            '.gradle',
            'node_modules',
            '.eggs',
            '.mypy_cache',
            '.venv',
            '*.egg-info',
            'build',
            'infra',
            'tools',
            'secrets',
            'charts', // Helm charts often have injected template strings that will fail general linting. Helm linting is done separately.
            'resources/seed/*_specs.yaml', // Do not remove - this is necessary to prevent diffs in our github workflows, as the file diff check runs between the Format step and the Build step, the latter of which generates the file.
            'resources/seed/*_catalog.json', // Do not remove - this is also necessary to prevent diffs in our github workflows
            'airbyte-integrations/connectors/source-amplitude/unit_tests/api_data/zipped.json', // Zipped file presents as non-UTF-8 making spotless sad
            'airbyte-webapp', // The webapp module uses its own auto-formatter, so spotless is not necessary here
            'airbyte-webapp-e2e-tests', // This module also uses its own auto-formatter
            'airbyte-connector-builder-server/connector_builder/generated', // autogenerated code doesn't need to be formatted
    ]

    return fileTree(dir: rootDir, include: pattern, exclude: excludes.collect { "**/${it}" })
}

spotless {
    java {
        target createSpotlessTarget('**/*.java')

        importOrder()

        eclipse('4.21.0').configFile(rootProject.file('tools/gradle/codestyle/java-google-style.xml'))

        File licenseFile = rootProject.file('LICENSE_SHORT')
        licenseHeaderFile licenseFile.length() > 0 ? createJavaLicenseWith(licenseFile) : licenseFile
        removeUnusedImports()
        trimTrailingWhitespace()
    }
    groovyGradle {
        target createSpotlessTarget('**/*.gradle')
    }
    sql {
        target createSpotlessTarget('**/*.sql')

        dbeaver().configFile(rootProject.file('tools/gradle/codestyle/sql-dbeaver.properties'))
    }
    format 'styling', {
        target createSpotlessTarget(['**/*.yaml', '**/*.json'])
        targetExclude([
                "**/helm/10-values.yaml",
                "**/helm/20-resources.yaml",
                "**/destination_definitions.yaml",
                "**/source_definitions.yaml",
                "**/cloud_catalog.json",
                "**/api_documentation_auto_generated.yaml"
        ])

        prettier()
    }
}

allprojects {
    apply plugin: 'base'
    apply plugin: 'com.bmuschko.docker-remote-api'

    task copyDocker(type: Sync) {
        from "${project.projectDir}/Dockerfile"
        into "build/docker/"
    }

    // by default gradle uses directory as the project name. That works very well in a single project environment but
    // projects clobber each other in an environments with subprojects when projects are in directories named identically.
    def sub = rootDir.relativePath(projectDir.parentFile).replace('/', '.')
    group = "io.${rootProject.name}${sub.isEmpty() ? '' : ".$sub"}"
    project.archivesBaseName = "${project.group}-${project.name}"

    version = rootProject.ext.cloud_version
}

// Java projects common configurations
subprojects { subproj ->

    task listAllDependencies(type: DependencyReportTask) {}
    apply plugin: 'checkstyle'
    apply plugin: 'java'
    apply plugin: 'jacoco'
    apply plugin: 'pmd'
    apply plugin: 'com.github.spotbugs'

    sourceCompatibility = JavaVersion.VERSION_17
    targetCompatibility = JavaVersion.VERSION_17

    repositories {
        maven {
            url 'https://airbyte.mycloudrepo.io/public/repositories/airbyte-public-jars/'
        }
        mavenCentral()
        mavenLocal()
    }

    checkstyle {
        configFile = rootProject.file('tools/gradle/checkstyle/checkstyle.xml')
        ignoreFailures = false
        showViolations = true
        toolVersion = '10.0'
    }

    jacoco {
        toolVersion = '0.8.8'
    }

    jacocoTestReport {
        dependsOn test
        reports {
            html.required = true
            xml.required = true
            csv.required = false
        }
    }

    jacocoTestCoverageVerification {
        violationRules {
            failOnViolation = false
            rule {
                element = 'CLASS'
                excludes = ['**/*Test*', '**/generated*']
                limit {
                    counter = 'BRANCH'
                    minimum = 0.8
                }
                limit {
                    counter = 'INSTRUCTION'
                    minimum = 0.8
                }
            }
        }
    }

    java {
        reporting.baseDir = "${rootProject.buildDir.path}/reports/${project.name}"
    }

    pmd {
        consoleOutput = true
        ignoreFailures = false
        rulesMinimumPriority = 5
        ruleSets = []
        ruleSetFiles = files(rootProject.file('tools/gradle/pmd/rules.xml'))
        toolVersion = '6.43.0'
    }

    spotbugs {
        ignoreFailures = false
        effort = 'max'
        excludeFilter = rootProject.file('spotbugs-exclude-filter-file.xml')
        reportLevel = 'high'
        showProgress = false
        toolVersion = '4.7.3'
    }

    test {
        jacoco {
            enabled = true
            excludes = ['**/*Test*', '**/generated*']
        }
        useJUnitPlatform()
        testLogging() {
            events 'failed'
            exceptionFormat 'full'
            // showStandardStreams = true
        }
        finalizedBy jacocoTestReport
    }

    dependencies {
        implementation(platform("com.fasterxml.jackson:jackson-bom:2.13.3"))
        implementation(platform("org.glassfish.jersey:jersey-bom:2.31"))


        // version is handled by "com.fasterxml.jackson:jackson-bom:2.10.4", so we do not explicitly set it here.
        implementation libs.bundles.jackson

        implementation libs.guava

        implementation libs.commons.io

        implementation libs.bundles.apache

        implementation libs.slf4j.api


        // SLF4J as a facade over Log4j2 required dependencies
        implementation libs.bundles.log4j

        // Bridges from other logging implementations to SLF4J
        implementation libs.bundles.slf4j

        // Dependencies for logging to cloud storage, as well as the various clients used to do so.
        implementation libs.appender.log4j2
        implementation libs.aws.java.sdk.s3
        implementation libs.google.cloud.storage

        implementation libs.s3

        // Lombok dependencies
        compileOnly libs.lombok
        annotationProcessor libs.lombok

        testCompileOnly libs.lombok
        testAnnotationProcessor libs.lombok

        testRuntimeOnly libs.junit.jupiter.engine
        testImplementation libs.bundles.junit
        testImplementation libs.assertj.core

        testImplementation libs.junit.pioneer

        // adds owasp plugin
        spotbugsPlugins libs.findsecbugs.plugin
    }

    tasks.withType(Checkstyle) {
        exclude '**/generated/**'
        exclude '**/jooq/**'
    }

    tasks.withType(Pmd) {
        exclude '**/generated/**'
        exclude '**/jooq/**'
    }

    tasks.withType(SpotBugsTask) {
        // Reports can be found under each subproject in build/reports/spotbugs/html
        reports {
            xml.required = false
            html.required = true
        }
    }

    // add licenses for python projects.
    def pythonFormatTask = project.tasks.findByName('blackFormat')

    if(pythonFormatTask != null) {
        apply plugin: "com.github.hierynomus.license"
        task licenseFormatPython(type: com.hierynomus.gradle.license.tasks.LicenseFormat) {
            header = createPythonLicenseWith(rootProject.file('LICENSE'))
            source = fileTree(dir: projectDir)
                    .include("**/*.py")
                    .exclude(".venv/**/*.py")
                    .exclude("**/__init__.py")
            strictCheck = true
        }
        def licenseTask = project.tasks.findByName('licenseFormatPython')
        blackFormat.dependsOn licenseTask
        isortFormat.dependsOn licenseTask
        flakeCheck.dependsOn licenseTask

        def generateFilesTask = project.tasks.findByName('generateProtocolClassFiles')
        if(generateFilesTask != null) {
            licenseTask.dependsOn generateFilesTask
        }
    }

    // Common Docker Configuration:
    // If subprojects have the dockerImageName property configured in their gradle.properties file,
    // register:
    // 1) A copyGeneratedTar task to copy generated TARs. Subprojects that produce TARs can use this
    //    to copy the produced tar into the docker image.
    // 2) A buildDockerImage task to build the docker image.
    // 3) Make the docker image task depend on the default assemble task.
    if (subproj.hasProperty('dockerImageName')) {
        subproj.pluginManager.withPlugin('application') {
            project.logger.lifecycle("Configuring docker task for $subproj.name...")
            // Although this task is defined for every subproject with the dockerImageName property,
            // It is not necessarily used for all subprojects. Non-TAR producing projects can ignore this.
            tasks.register("copyGeneratedTar", Copy) {
                dependsOn copyDocker
                dependsOn distTar
                from('build/distributions') {
                    // Assume that tars are named <parent-project-name>-<child-project-name>-*.tar.
                    // Because we only have a handle to the child project, and to keep things simple,
                    // use a * regex to catch all prefixes.
                    include "*$subproj.name-*.tar"
                }
                into 'build/docker/bin'
            }
        }

        tasks.register("buildDockerImage", DockerBuildImage) {
            group = "buildDockerImage"
            def arch = System.getenv('BUILD_ARCH') ?: System.getProperty("os.arch").toLowerCase()
            def isArm64 = arch == "aarch64" || arch == "arm64"

            def buildPlatform = System.getenv('DOCKER_BUILD_PLATFORM') ?: isArm64 ? 'linux/arm64' : 'linux/amd64'
            def buildArch = System.getenv('DOCKER_BUILD_ARCH') ?: isArm64 ? 'arm64' : 'amd64'

            platform = buildPlatform
            images.add("airbyte/$subproj.dockerImageName:$rootProject.ext.image_tag")
            buildArgs.put('DOCKER_BUILD_ARCH', buildArch)
            buildArgs.put('VERSION', rootProject.ext.cloud_version)
        }

        tasks.named("assemble") {
            dependsOn buildDockerImage
        }
    }

    check.dependsOn 'jacocoTestCoverageVerification'
}

task('generate') {
    dependsOn subprojects.collect { it.getTasksByName('generateProtocolClassFiles', true) }
    dependsOn subprojects.collect { it.getTasksByName('generateJsonSchema2Pojo', true) }
}

task('format') {
    dependsOn generate
    dependsOn spotlessApply
    dependsOn subprojects.collect { it.getTasksByName('airbytePythonFormat', true) }
}

task('archiveReports', type: Tar) {
    archiveFileName = "${project.name}-reports.tar"
    destinationDirectory = layout.buildDirectory.dir('dist')
    from layout.buildDirectory.dir('reports')
}

// Automatically execute formatting during builds
check.dependsOn format

// Automatically archive reports generated during builds
build.finalizedBy archiveReports

// produce reproducible archives
// (see https://docs.gradle.org/current/userguide/working_with_files.html#sec:reproducible_archives)
tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}
